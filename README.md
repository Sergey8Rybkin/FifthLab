# Лабораторная работа № 5 Создание индивидуальной системы достижения пользователя и ее интеграция в пользовательский интерфейс

Отчет по лабораторной работе #4 выполнил:
- Рыбкин Сергей Денисович
- РИ-300012

[Репозиторий с проектом](https://github.com/Sergey8Rybkin/Dragon-Picker)

[Черновик игры на Яндекс Играх](https://yandex.ru/games/app/198497?draft=true&lang=ru)

Отметка о выполнении заданий:

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | * | 20 |
| Задание 3 | # | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.

____

### Цель работы:
создание интерактивного приложения с рейтинговой системой пользователя и интеграция игровых сервисов в готовое приложение.

### Задание 1
Используя видео-материалы практических работ 1-5 повторить реализацию приведенного ниже функционала:
–	1 Практическая работа «Интеграции авторизации с помощью Яндекс SDK»
–	2 Практическая работа «Сохранение данных пользователя на платформе Яндекс Игры»
–	3 Практическая работа «Сбор данных об игроке и вывод их в интерфейсе»
–	4 Практическая работа «Интеграция таблицы лидеров»
–	5 Практическая работа «Интеграция системы достижений в проект» 

### Задание 2
Описать не менее трех дополнительных функций Яндекс SDK, которые могут быть интегрированы в игру. 

### Задание 3
Доработать стилистическое оформление списка лидеров и системы достижений, реализованных в задании 1.


## Задание 1.

Мы продолжаем работу с нашим проектом. Первой задачей мы ставим проверку авторизации пользователя на платформе **Yandex Games**. Для этого нам необходимо чтобы был установлен плагин, его я установил в лабораторной работе ранее. Установить необходимось авторизации пользователя в настройках проекта на Яндекс Играх. Так-же нам нужен внутри нашего проекта скрипт который будет проводить проверку авторизации пользователя, и если он не авторизован вызывать окно авторизации.

Начнём со скрипта. Нам нужны 3 функции. OnEnable OnDisable для проверки данных ЯндексSDK, которые при необходимости будут вызывать третью функцию CheckSDK, в которой мы будем проверять авторизацию пользователя и вызывать окно авторизации. При старте работы программы мы так-же будем проводить проверку и выводить в консоль что всё в порядке.

```c#
using YG;
public class CheckConnectYG : MonoBehaviour
{
    
    private void OnEnable() => YandexGame.GetDataEvent += CheckSDK;
    private void OnDisable() => YandexGame.GetDataEvent -= CheckSDK;
        
    
    void Start()
    {
        if (YandexGame.SDKEnabled == true) {
            CheckSDK();
        }
    }

   public void CheckSDK()
   {
    if (YandexGame.auth == true)
    {
        Debug.Log("User is authorized");
    }
    else 
    {
        Debug.Log("User is not authorized");
        YandexGame.AuthDialog();
    }
   }
}
```

На сцене создаём пустой объект и вкладываем в него наш скрипт. В дальнейшем к этому объекту можно будет прикручивать все манипуляции с YandexSDK.
Проверку внутри Unity мы провести не сможем, тк нет подключения к Яндекс играм. Поэтому мы собираем билд и идём тестировать на платформе в черновике. Так-же не забываем поставить флажок на возможности пользователя авторизоваться в игре.

![image](https://user-images.githubusercontent.com/100475554/203953556-534a73f2-3ef8-42e5-ba36-d81350b65029.png)

Итого выложив игру на Яндекс игры мы получаем положительный ответ от страницы, с такими данными из консоли 
![image](https://user-images.githubusercontent.com/100475554/203968239-3675e761-e1cb-4c2a-9663-1709fd8bd459.png)

Так-же проверим в браузере где я не вошёл в аккаунт. Как мы можем увидеть, Яндекс проверил мою авторизацию и просит войти в аккаунт, чтобы достижения сохранялись
![image](https://user-images.githubusercontent.com/100475554/203968701-78fac19b-a634-4139-8320-867fc5c870c5.png)

Займёмся сохранением данных игрока в системе Яндекс игр. Для этого в плагине есть скрипт SavesYG, в нём нам нужно инициализировать переменную *score* в которую мы будем записывать и сохранять прогресс игрока. Теперь осталось только сделать связку сохранения очков нашего проекта и новой переменной. Для этого нам необходимо в скрипте подсчёта очков **DragonPicker** добавить следующие строки кода.

Для проверки подключения YandexSDK и подключения UI в который мы передаём очки.
```c#
private void OnEnable() => YandexGame.GetDataEvent += GetLoadSave;
   
private void OnDisable() => YandexGame.GetDataEvent -= GetLoadSave;

public TextMeshProUGUI scoreGT;
```

В старт мы добавляем проверку подключения и выводим сохранённые данные об игроке
```c#
if (YandexGame.SDKEnabled == true) 
        {
            GetLoadSave();
        }
```
Создаём функцию для отображения данных об игроке
```c#
public void GetLoadSave()
    {
        Debug.Log(YandexGame.savesData.score);
    }
```
И метод сохраняющий данные в облако Яндекс Игр
```c#
public void UserSave( int currentScore)
    {
        YandexGame.savesData.score = currentScore;
        YandexGame.SaveProgress();
    }

```
При выгрузке нового билда так-же не забываем подключить облачные сохранения.
![image](https://user-images.githubusercontent.com/100475554/203980525-83621554-99e7-46d8-bbae-e2a0f299d654.png)

При тестировании, в консоли можно увидеть что за две сессии, сначала сохранились данные о 10 очках, а после второй попытки у нас сохранились 5 очков

![image](https://user-images.githubusercontent.com/100475554/203982616-6d3355a0-55e0-4633-931d-d3d6dea7b6d1.png)

Ещё одним дополнением к интерфейсу игрока будет приветствие его по имени. 
P.S. Я решил не делать имя игрока сверху нашего мага, тк считаю что это бессмысленно для игровой сцены. Игроку никак не нужно в ней сигнализировать о том где его персонаж, он управляет щитами и использует заклинания не зависимо от положения модели.

Я добавил новый текстовый объект на сцену, назвал его WelcomePlayer. Теперь нам нужно в скрипте подключиться к ЯндексSDK, и передать из него имя человека играющего в игру.

### Результат во вьюпорте юнити
![unknown_2022 12 06-22 29_1](https://user-images.githubusercontent.com/100475554/205981675-833daf9d-d56e-4200-b76f-91b8ac1326ce.gif)

Ну и строки кода необходимые нам для этого. Прописал всё в скрипте CheckConnectYG, там же мы реализовывали лучшее количество очков игрока немнго раньше.
```c#
GameObject playerNamePrefabGUI = GameObject.Find("WelcomePlayer");
    playerName = playerNamePrefabGUI.GetComponent<TextMeshProUGUI>();
    playerName.text =  "Hello " + YandexGame.playerName;
```

Единственное работу нельзя проверить в черновике YG.

Итак мы сделали приветствие пользователя и научились показывать ему его лучший счёт. Но мы не в 2000х, чтобы игрок соревновался только сам с собой, да и по правде уже тогда игроки боролись за место в таблице игровых автоматов. Создадим таблицу очков, в которой игроки смогут бороться за первенство. 

В нашем проекте нам нужны лишь плагин YG и строчка кода, которая будет заносить лучший счёт игроков в таблицу.

```c#
YandexGame.NewLeaderboardScores("BestPlayerScore", int.Parse(scoreGT.text));
```

Пересобираем билд, и пока он выгружается на YandexGame, нам нужно поставить один флажок и изменить данные в разделе **Лидерборды**

![image](https://user-images.githubusercontent.com/100475554/205984789-0e5758d4-416e-499a-acc6-4a9eb9b07809.png)

![image](https://user-images.githubusercontent.com/100475554/205984871-d87b37b4-7eb3-46ae-9167-0b1958c9eb8d.png)

![image](https://user-images.githubusercontent.com/100475554/205984915-a5f08e61-6e4b-4e6a-b27c-d695de34043b.png)
